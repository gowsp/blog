title: Jvm垃圾回收概念指标
date: 2020-10-23
tags:
- Jvm
---
从接触Java的第一刻起就被灌输Java是健壮的，其健壮主要体现在垃圾回收方面，那么如何去学习垃圾回收呢？虽然经常在一些博文和公众号文章里看到相关知识但始终觉得管中窥豹，只见一斑，前不久一位同事询问垃圾回收相关知识时更是发现原来自己对其了解和学习还不够的，于是翻遍官网每个角落最后找到了[内存管理白皮书](https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)，对Jvm内存管理的讲解非常系统全面，个人认为是内存管理的必读之作，堪称圣经。这里我就整理输出一下。
<!--more-->
## 概要

这里主要引用了白皮书中第三章的内容，其内容主要包含以下几部分：

- 垃圾回收概念
- 理想垃圾回收器
- 垃圾回收器算法设计和选用的几个维度
- 垃圾回收器性能指标

第三章的内容系统全面又丰富，下面就来一一介绍下相关内容。

## 垃圾回收概念

垃圾回收使用精确算法对堆内存进行分配和释放，该处理逻辑对程序员隐藏。
我们知道被引用的对象是存活有效的，不再引用的对象是无效对象，称为垃圾，查找释放（也称为回收）无效对象占用内存的过程称为垃圾回收。
垃圾回收可以解决大部分但不是全部的内存分配问题，其本身同样是一项复杂费时且消耗资源的任务。垃圾回收器需要在堆上寻找一块大小合适的空间来处理分配请求，这通常是比较困难的，且在分配算法中要避免碎片化同时保证分配释放的高效性。

## 理想垃圾回收器特征

理想的垃圾回收器应具备以下特性

- 安全且全面，被引用的对象绝对不能被释放，而垃圾对象在几个小回收周期之后不能存在。
- 高效工作，垃圾回收应避免在工作时对应用带来长时间的暂停，但通常比较困难需要在空间和频率上进行权衡。小内存垃圾回收很快但经常填满因此回收操作比较频繁，而大内存回收时间较长填满较慢因此回收频率不那么高。
- 限制内存的碎片化。当垃圾对象的内存被释放，可能会释放出一系列不连续的小空间，这些空间由于不够大而无法被用来分配大对象。一种解决办法就是通过压缩来实现，这在后面会有提到。
- 可伸缩性。垃圾回收器的分配和回收操作不能成为多处理器系统上多线程程序的可伸缩的瓶颈。

## 设计和选用维度

在设计和选择垃圾回收方面有几个维度的考量，下面就来逐一介绍下：

### 串行与并行

串行回收器即同一时间只处理一件事。例如，即使有多个可用的CPU，也只利用一个CPU来执行回收。使用并行回收时，垃圾回收任务被分为多个子任务，这些子任务在不同的CPU上同时运行。同时运行可以更快地完成垃圾回收，但会增加额外的复杂度并带来潜在碎片化的问题。

### 并发与Stop-the-world

Stop-the-world回收器在回收过程中会将程序执行完全暂停。 并发回收器则可以在程序运行期间执行一个或多个垃圾回收任务，当然有时可能不得不进行一些短暂的停顿。 Stop-the-world垃圾回收器比并发回收器更简单，因为堆被冻结并且回收期间对象不会更改，其缺点是某些程序不希望被暂停。并发回收器进行垃圾回收时，暂停时间会缩短，但是回收器必须格外小心，因为应用程序可能同时对待回收对象进行操作，这对并发回收器增加了一些开销，会影响性能并需要更大的堆空间。

### 压缩与非压缩与复制

垃圾回收器确定内存对象哪些是活动对象哪些是垃圾后，可以将所有活动对象一起移动并完全回收剩余的内存进行压缩。压缩之后，可以在空闲内存的起始位置轻松快速地分配一个新对象，并利用一个简单的指针来跟踪下一个可分配的位置。
与压缩回收器相反，非压缩回收器仅释放垃圾对象空间，不会像压缩回收器一样移动所有活动对象来创建较大的回收区域。这样的好处是可以更快地完成垃圾回收，但缺点是可能会产生碎片区域。与非压缩类型的回收器相比在分配对象时成本更大，它必须要在堆中寻找到大小适中的内存区域以容纳新对象。
第三种是复制回收器，其将活动对象复制（或移动）到不同的内存存储区域。这样的好处是可以将源区域清空，用于快速方便的后续分配，但是缺点是复制需要更多的时间以及额外的空间。

## 性能指标

可以利用多个指标来评估垃圾回收器的性能：

- 吞吐量（Throughput），在一段较长的时间内未进行垃圾回收的占用时间比例
- 垃圾回收开销（Garbage collection overhead），与吞吐量相反，在一段较长的时间内垃圾回收的占用时间比例
- 暂停时间（Pause time），在程序运行过程中由于垃圾回收导致暂停的时间
- 回收频率（Frequency of collection），相对于应用程序执行，垃圾回收发生的频率
- 占用空间（Footprint），大小的度量，例如堆大小
- 及时性（Promptness），对象变成垃圾后内存释放可用之间的时间。

在不同的场景下需要考虑的指标各不相同。重交互的应用可能需要较短的暂停时间，而总执行时间对非交互应用程序更重要，实时应用程序则需要较小的暂停时间和垃圾回收开销。

## 写在最后

其实上面这些内容只是基于原版内容的一个粗糙翻译，但是对我来讲可以快速理解上手，希望可以帮到各位。
